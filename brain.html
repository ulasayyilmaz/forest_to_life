<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.555">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Predicting Biodiversity by Change in Forest Mass</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="brain_files/libs/clipboard/clipboard.min.js"></script>
<script src="brain_files/libs/quarto-html/quarto.js"></script>
<script src="brain_files/libs/quarto-html/popper.min.js"></script>
<script src="brain_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="brain_files/libs/quarto-html/anchor.min.js"></script>
<link href="brain_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="brain_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="brain_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="brain_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="brain_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body>

<div id="quarto-content" class="page-columns page-rows-contents page-layout-full">

<main class="content column-page" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Predicting Biodiversity by Change in Forest Mass</h1>
</div>



<div class="quarto-title-meta column-page">

    
  
    
  </div>
  


</header>


<!-- Inline Style to Fix Alignment -->
<style>
  /* Ensure body and html occupy full viewport width */
  html, body {
    margin: 0;
    padding: 0;
    width: 100vw; /* Full viewport width */
    overflow-x: hidden; /* Prevent horizontal scrolling */
  }

  /* Make header and sections span full width */
  header, section {
    margin: 0;
    padding: 20px;
    width: 100vw; /* Full viewport width */
    box-sizing: border-box; /* Include padding in width */
  }

  /* Header styling */
  header {
    background-color: #d9d2e9;
    display: flex;
    align-items: center;
    justify-content: space-between;
  }

  nav ul {
    list-style: none;
    display: flex;
    margin: 0;
    padding: 0;
  }

  nav ul li {
    margin-right: 20px;
  }

  nav ul li a {
    text-decoration: none;
    color: black;
    font-weight: bold;
  }

  /* Section background colors */
  #introduction {
    background-color: #fef4e5;
  }

  #data {
    background-color: #e8f5e9;
  }

  #methods {
    background-color: #e3f2fd;
  }

  #limitations {
    background-color: #ede7f6;
  }

  #discussion {
    background-color: #ffebee;
  }
</style>
<!-- Custom HTML for Header -->
<header>
<nav>
<ul>
<li>
<a href="#introduction">Introduction</a>
</li>
<li>
<a href="#data">Data</a>
</li>
<li>
<a href="#methods">Methods</a>
</li>
<li>
<a href="#limitations">Limitations</a>
</li>
<li>
<a href="#discussion">Discussion</a>
</li>
</ul>
</nav>
<img src="images/Pomona_College_seal.png" alt="Logo" style="height: 60px; margin-left: auto;">
</header>
<!-- Sections -->
<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p>Content for the introduction section.</p>
</section>
<section id="data" class="level2">
<h2 class="anchored" data-anchor-id="data">Data</h2>
<p>Content for the data section.</p>
</section>
<section id="methods" class="level2">
<h2 class="anchored" data-anchor-id="methods">Methods</h2>
<p>Content for the methods section.</p>
</section>
<section id="limitations" class="level2">
<h2 class="anchored" data-anchor-id="limitations">Limitations</h2>
<p>Content for the limitations section.</p>
</section>
<section id="discussion" class="level2">
<h2 class="anchored" data-anchor-id="discussion">Discussion</h2>
<p>Content for the discussion section.</p>
</section>
<div class="cr-section">
<div id="cr-ishika">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="Data_tracking.png" class="img-fluid figure-img"></p>
<figcaption>Privacy Nutrition Labels</figcaption>
</figure>
</div>
</div>
<p>Privacy Terms Final Project Proposal</p>
<p>Group Members:</p>
<p>Ishika Keswani <span class="citation" data-cites="cr-ishika">@cr-ishika</span> Group Role: Task Manager. Ishika is the brains of this proposal, as the proposed project is a spinoff from her 10-week SURP project which she presented a poster on. Therefore, she will be responsible for delegating tasks based on both our’s relative expertise.</p>
<p>Project Role: Ishika conducted many user studies, and is familiar with common pain points and main misunderstood terms in both IOS and Android Privacy Labels. Ishika will be the mainly responsible person for creating a simplified version of the super complex Privacy Terms. Ishika’s insight and intuition will come in super handy for this task. Ishika will also be responsible for leading the web-scraping/online data processing process.</p>
<p>Ulas Ayyilmaz Group Role: Project Manager: Ulas will be on top of each meeting scheduling, as well as checking if goals are met, upholding a clear structure to achieve the end product in the desired time. Project Role: Ulas will be responsible for building the backend as well as the front end of an extension that will allow the feature of hovering your mouse on a term and seeing it’s simplified version. Ulas will also contribute to webscraping. Ulas and Ishika will code both “What percent of similar apps found on google play store” feature, as well as the role of demographic background of an individual on their understanding of the terms (data collected by Ishika’s research group.</p>
</div>
<p>TITLE: Understanding User Privacy in Android Devices Broad Topic: Exploring terms found in Android Privacy ‘Nutrition Labels’ and creating an interface/website/app wherein users could input an android app store link (no privacy issues with android which makes web-scraping a much easier process J) and have as an output a simplified version of the terms and whether they are collected or shared, and what percentage of ‘similar apps’ found on the google play store collect/share each particular variable type. Additionally, if time permits, we could include a feature wherein hovering the cursor over a term would lead to a small projection on the screen containing a simplified explanation/definition of the term to increase accessibility of this information and negate the need to go to a whole different page or look up the definition.</p>
<p>Data &amp; Variables &amp; End Product: Taking inspiration from the New York Times tree in the Decision Trees topic notes on the website, I thought it would be interesting to create a scrollytelling graphic/image of a similar tree which could explore:</p>
<ol type="1">
<li><p>How demographics impact which terms from the android list of terms are more or less widely understood (information available via the full study we conducted as surveyed individuals were required to report their demographics) or how demographics determine whether an individual would get the definition of a term correct, partially correct, wrong, restate the term, or say they don’t know the answer.</p></li>
<li><p>We divided the terms into categories based on the results of a follow up study we conducted wherein users were given the definition/meaning of a term in colloquial language and were asked to suggest phrases/term names for each of them such that it would be easiest to understand. The categories were 1) Terms whose diction needed to be clarified, 2) Terms that were too broad or needed to be split up into multiple smaller terms, 3) Terms including the word ‘other’, 4) Terms with no good alternatives, 5) Terms lacking nuance. We could also see how correctness of the term differed across these categories and whether we could use correctness and user demographics to predict which category a term would fall under. Another use of data in this project could link back to the segment about the ‘similar apps’ on the app store. We could also use graphics and other available data (such as number of downloads of an app, rating of an app, number of apps with the same function, etc.) to determine whether we can create a model - possibly integrating methods that our out of the scope of Compstats such as deep NNs - to predict if an app collects/shares more or less data than other similar apps which perform the same function.</p></li>
</ol>
<p>Update</p>
<ol type="1">
<li>Have you already collected, or do you have access to, all of the data that you will need in order to complete your project? If not, please estimate the percentage of the data that you have, describe any issues that you are having, and what your plan is for getting the rest of the data.</li>
</ol>
<p>We have three big datasets that we will draw our data from. i. Our first dataset is a dataset of 300+ users for each row, and all “misunderstood” terms as all columns - the misunderstood terms were designated after a pilot study conducted by Ishika Keswani during the summer where a group of people explained what they understood from all Android app terms, and Ishika’s lab group classified all the terms according to if they have been “misunderstood” based on some critera by more than 67% (2/3) of the people.This dataset lists if the main experiment participants of 300+ people understand the “misunderstood” terms, so each cell is “correct”, “wrong”, “partially correct”, “I don’t know”, or a restate”. ii. Our second dataset is a massiv edataset consisting of 100,000+ json files, each listing information for a single application. We have two datasets, one for IOS, and the other for Android. Eachjson file lists app information, including various charasteristic labels of the app, that specific if a particular data is collected (user, location, activity time…) relating to terms. We will use this information to calculate what data is collected in what percent of all the apps, and can create vizualizations about what are the most misunderstood terms whose respective data is collected by most apps. iii. LAst dataset is a excel dataset with people telling how they would rephrase the misunderstood terms, for each term.</p>
<p>We also know how to se Play Store API to webscrape from all apps from playstore if need be, to calculate similarities or any other metric.</p>
<ol start="2" type="1">
<li>What is the single biggest unresolved issue you are having? Please describe it briefly, and what your plan is for resolving this issue.</li>
</ol>
<ol type="i">
<li>Learning backend of scrollytelling.</li>
<li>We still need to learn to code the part that takes in a URL of a google play store app, and is able to scrape the labels as a json file, immediately generating statistics and respective visualizations.</li>
</ol>
<ol start="3" type="1">
<li>What are the elements from outside of the course, if any, that you plan to incorporate into your project?</li>
</ol>
<ol type="i">
<li>Webscaping from google play store applications into json files</li>
<li>Buidling a webpage using HTML, CSS, javascript</li>
<li>Scrollytelling</li>
<li>Training a ML algorithm (ie Deep NEural NEtwork) for some purpose. (we are uncertain as of now).</li>
</ol>
<p>Updates on work: 1- Realized that the requests from the api returned NULL. This might be because some countries in specified years don’t have specific bird data. Testing hypothesis now. 2- Found that bird_data&lt;-name_suggest(q = “Aves”, rank = “class”) most of the time threw a timeout error. Fixed the error by increasing timeout: bird_data&lt;-name_suggest(q = “Aves”, rank = “class”, curlopts = list(timeout = 60)) 3- Saw that calling for key column of the bird_data always returned Null. Changed bird_data<span class="math inline">\(key -&gt; bird_data\)</span>data$key. Works! Tax_key of bird “aves” is 212.</p>
<p>4- couldn’t figure out a way to mass download all data - probably because the size is too large. Pivoted to using specific bird species and downloading from the website one by one. Found bird species that majorly live in forests, wetlands, and shrublands. Comparing their predictability.</p>
<p>5- merged all bird datasets into all_bird_orders_data.csv</p>
<p>Birds: Forest: Coraciiformes (623,438): Strigiformes (420,677): Owls. Often found in forests and woodlands.</p>
<p>Ground-shrubland Galliformes (680,284): Chickens, turkeys, and quails. Found in grasslands, forests, and shrublands.</p>
<p>Wedlands Ciconiiformes (64,794): Storks. Found in wetlands and grasslands.</p>
<ol start="6" type="1">
<li>I just figured out that entries belonging to year 2000 are significantly less then entries belonging to year 2020. So when I see an enourmous increase between 2000,2020, in a species, it doesn’t imply a major increase in animal’s population. In order to tackle this problem, first</li>
</ol>
<ol type="i">
<li>on the model_data, which is the grouped (country, year, order) summarize n() for count, I applied log function to order_counts, so that the increase from 2000 to 2010 is not as sharp, implying that the bird populations don’t increase exponentially: log_count variable</li>
<li>on the log-scaled data called model_data_log, I normalized each log_count globally between 0-1.</li>
</ol>
<section id="visualize-svm-model-performance" class="level1">
<h1>Visualize SVM model performance</h1>
<p>svm model only predicts the b3 class, which has the most observation(4) compared to other classes. knn predicts well for train dataset, not so well but still above average for test. random forest</p>
<ol start="7" type="1">
<li>Scrollytelling used to work before, is not working anymore.</li>
</ol>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>